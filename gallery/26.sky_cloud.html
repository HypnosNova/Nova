<!DOCTYPE html>
<html lang='en' class=''>

  <head>
    <meta charset='UTF-8'>
    <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />

  </head>

  <body>

    <script src="https://cdn.bootcss.com/lodash.js/4.17.5/lodash.min.js"></script>
    <script src="../lib/three.min.js"></script>
    <script src="../build/nova.js"></script>
    <script>
      let app = new NOVA.App();
      app.world.camera.position.z = 80;

      const ANIMATION_FRAME_LENGTH = 30;
      const INTERACT_DISTANCE = 2.5;
      const SCREEN_HEIGHT = app.getWorldHeight();
      const SCREEN_WIDTH = app.getWorldWidth();
      const BITMAP_SKIP = 1;

      var viewHeight = 2 * Math.tan(THREE.Math.degToRad(app.world.camera.fov / 2)) * app.world.camera.position.z;
      var viewWidth = viewHeight * SCREEN_WIDTH / SCREEN_HEIGHT;

      let data = '#000000000000000000011110000000000000000000' +
        '#000000000000000011111111110000000000000000' +
        '#000000000000001111111111111100000000000000' +
        '#000000000000011111111111111110000000000000' +
        '#000000000000111111111111111111000000000000' +
        '#000000000001111111111111111111100000000000' +
        '#000000000011111111111111111111110000000000' +
        '#000000000011111111111111111111110000000000' +
        '#000000000111111111111111111111111000000000' +
        '#000000000111111111111111111111111000000000' +
        '#000000001111111111111111111111111100000000' +
        '#000000001111111111111111111111111100000000' +
        '#000000001111111111111111111111111100000000' +
        '#000000001111111111111111111111111100000000' +
        '#000000001111111111111111111111111100000000' +
        '#000000000111111111111111111111111000000000' +
        '#000000000111111111111111111111111000000000' +
        '#000000000111111111111111111111111000000000' +
        '#000000000011111111111111111111110000000000' +
        '#000000000011111111111111111111110000000000' +
        '#000000000001111111111111111111100000000000' +
        '#000000000001111111111111111111100000000000' +
        '#000000000000111111111111111111000000000000' +
        '#000000000000111111111111111110000000000000' +
        '#000000000000011111111111111110000000000000' +
        '#000000000000001111111111111100000000000000' +
        '#000000000000001111111111111100000000000000' +
        '#000000000000001111111111111000000000000000' +
        '#000000000000000111111111111000000000000000' +
        '#000000000000000111111111111000000000000000' +
        '#000000000000000111111111111000000000000000' +
        '#000000000000000111111111111000000000000000' +
        '#000000000000000011111111110000000000000000' +
        '#000000000000000010000000010000000000000000' +
        '#000000000000000011111111110000000000000000' +
        '#000000000000000010000000010000000000000000' +
        '#000000000000000011111111110000000000000000' +
        '#000000000000000010000000010000000000000000' +
        '#000000000000000011111111110000000000000000' +
        '#000000000000000000100001000000000000000000' +
        '#000000000000000000110011000000000000000000' +
        '#000000000000000000011110000000000000000000';

      let objetArray = [],
        animationQueue = [];
      let color1 = [0 / 255, 110 / 255, 255 / 255],
        color2 = [0 / 255, 255 / 255, 140 / 255];

      let mouse = new THREE.Vector3(10000, 10000, -1),
        mouseScaled = new THREE.Vector3(10000, 10000, -1);

      let bitmap = [];
      createParticle();

      function createParticle() {
        for (var i = 0; i < data.length; i++) {
          if (data[i] == '#') {
            bitmap.push([]);
          } else {
            bitmap[bitmap.length - 1].push(data[i] - '0');
          }
        }
        let planeGeometry = new THREE.PlaneGeometry(1, 1);
        let circleGeometry = new THREE.CircleGeometry(1, 5);
        var xOffset = -bitmap[0].length / (BITMAP_SKIP * 2);
        var yOffset = bitmap.length / (BITMAP_SKIP * 2);
        for (var i = 0; i < bitmap.length; i += BITMAP_SKIP) {
          for (var j = 0; j < bitmap[i].length; j += BITMAP_SKIP) {
            if (bitmap[i][j] == 1) {
              var frac = i / bitmap.length;
              planeMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(
                  color1[0] * frac + color2[0] * (1 - frac),
                  color1[1] * frac + color2[1] * (1 - frac),
                  color1[2] * frac + color2[2] * (1 - frac)
                ),
                transparent: true,
                opacity: THREE.Math.randFloat(0.4, 0.6),
                side: THREE.DoubleSide
              });

              planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
              planeMesh.position.set(xOffset + j / BITMAP_SKIP, yOffset - i / BITMAP_SKIP, 0);
              var randWidth = THREE.Math.randFloat(0.6, 1.2);
              var randHeight = randWidth
              planeMesh.scale.set(randWidth, randHeight, 1);
              app.world.scene.add(planeMesh);
              objetArray.push([planeMesh, false]);
            }
          }
        }
      }

      app.renderer.domElement.addEventListener('mousemove', onDocumentMouseMove, false);

      function onDocumentMouseMove(event) {
        var rect = app.renderer.domElement.getBoundingClientRect();
        mouse.x = event.clientX - rect.left;
        mouse.y = event.clientY - rect.top;
        mouseScaled.x = mouse.x * viewWidth / SCREEN_WIDTH - viewWidth / 2;
        mouseScaled.y = -mouse.y * viewHeight / SCREEN_HEIGHT + viewHeight / 2;
      }

      app.logicLoop.add(() => {
        while (animationQueue.length > 0) {
          var obj_index = animationQueue[0][0];
          var ani_frame = animationQueue[0][1];
          if (ani_frame > ANIMATION_FRAME_LENGTH) {
            objetArray[obj_index][1] = false;
            animationQueue.shift();
          } else {
            break;
          }
        }

        for (var i = 0; i < objetArray.length; i++) {
          var obj = objetArray[i][0];
          var isAnimating = objetArray[i][1];
          if (isAnimating == false) {
            var px = obj.position.x;
            var py = obj.position.y;
            var dist = Math.sqrt(Math.pow(px - mouseScaled.x, 2) + Math.pow(py - mouseScaled.y, 2));
            if (dist < INTERACT_DISTANCE) {
              var startPosVector = obj.position.clone();
              var mouseRepelVector = new THREE.Vector3()
                .subVectors(startPosVector, mouseScaled)
                .multiplyScalar(THREE.Math.randFloat(INTERACT_DISTANCE + 0.5, INTERACT_DISTANCE + 2) - dist);
              var endPosVector = new THREE.Vector3()
                .addVectors(startPosVector, mouseRepelVector);
              animationQueue.push([i, 0, startPosVector, endPosVector]);
              objetArray[i][1] = true;
            }
          }
        }

        for (var i = 0; i < animationQueue.length; i++) {
          var obj = objetArray[animationQueue[i][0]][0];
          var ani_frame = animationQueue[i][1];
          var startPosVector = animationQueue[i][2];
          var endPosVector = animationQueue[i][3];
          var curPosVector = new THREE.Vector3();
          var frac = 1 - Math.abs(ani_frame - (ANIMATION_FRAME_LENGTH / 2)) / (ANIMATION_FRAME_LENGTH / 2);
          frac = easeOutQuad(frac);
          curPosVector.lerpVectors(startPosVector, endPosVector, frac);

          obj.position.x = curPosVector.x;
          obj.position.y = curPosVector.y;
          obj.position.z = curPosVector.z;
          animationQueue[i][1] += 1;
        }

        mouse = new THREE.Vector3(10000, 10000, -2);
        mouseScaled = new THREE.Vector3(10000, 10000, -2);
      });

      function easeOutQuad(t) {
        return t * (2 - t);
      }
    </script>
  </body>
</html>